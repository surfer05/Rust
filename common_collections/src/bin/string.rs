fn main() {
    // We discuss strings in the context of collections because strings are implemented as a collection of bytes, plus some methods to provide useful functionality when those bytes are interpreted as text.

    // Rust has only one string type in the core language, which is the string slice str that is usually seen in its borrowed form &str.

    // The String type, which is provided by Rust’s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type.

    // CREATING A NEW STRING

    // This line creates a new empty string called s, which we can then load data into.
    let mut s = String::new();

    // Often, we’ll have some initial data that we want to start the string with. For that, we use the to_string method, which is available on any type that implements the Display trait, as string literals do.
    let data = "Initial contents";
    let s1 = data.to_string();

    // Using the to_string method to create a String from a string literal
    let s2 = "initial_contents".to_string();

    // We can also use the function String::from to create a String from a string literal.
    // Using the String::from function to create a String from a string literal
    let s3 = String::from("Initial contentss");

    // Remember that strings are UTF-8 encoded, so we can include any properly encoded data in them
    let hello = String::from("السلام عليكم");
    let hello = String::from("Dobrý den");
    let hello = String::from("Hello");
    let hello = String::from("שָׁלוֹם");
    let hello = String::from("नमस्ते");
    let hello = String::from("こんにちは");
    let hello = String::from("안녕하세요");
    let hello = String::from("你好");
    let hello = String::from("Olá");
    let hello = String::from("Здравствуйте");
    let hello = String::from("Hola");

    // UPDATING A STRING

    // Appending to a String with push_str and push

    // Appending a string slice to a String using the push_str method
    let mut s = String::from("22");
    // The push_str method takes a string slice because we don’t necessarily want to take ownership of the parameter.
    s.push_str("19");

    // The push method takes a single character as a parameter and adds it to the String.
    let mut s = String::from("lo");
    s.push('l');

    // Concatenation with the + Operator or the format! Macro
    let s4 = String::from("Hello, ");
    let s5 = String::from("World!");
    let s6 = s4 + &s5;   // note: s1 has been moved here and can no longer be used

    // the reason we used a reference to s2, has to do with the signature of the method that’s called when we use the + operator. The + operator uses the add method, whose signature looks something like this:
    fn add(self, s: &str) -> String {}
    // We can only add a &str to a String; we can’t add two String values together. But wait—the type of &s2 is &String, not &str, as specified in the second parameter to add.
    // The reason we’re able to use &s2 in the call to add is that the compiler can coerce the &String argument into a &str. 
    // When we call the `add` method, Rust uses a `deref coercion`, which here turns &s2 into &s2[..]

    // Concatenating multiple strings
    let a1 = String::from("tic");
    let a2 = String::from("tac");
    let a3 = String::from("toe");

    let a = s1 + "-" + &s2 + "-" + &s3;

    let b1 = String::from("tic");
    let b2 = String::from("tac");
    let b3 = String::from("toe");

    //  The `format!` macro works like println!, but instead of printing the output to the screen, it returns a String with the contents. The version of the code using `format!` is much easier to read, and the code generated by the `format!` macro uses references so that this call doesn’t take ownership of any of its parameters.
    let b = format!("{s1}-{s2}-{s3}");

    // INDEXING-INTO-STRINGS

    Indexing is not possible in strings cause their the byte storage of different UTF-8 characters in different. For example,in "Здравствуйте" , every character is of size two bytes, 
    and thus let s = &hello[0..4] would mean "Зд" and not "Здра". 
    There are some more problems with the Hindi language.
    the Hindi word “नमस्ते” is of size 18 bytes and it's not possible to provide indexing for every byte just by looking at the word.

    Instead we prefer to slice strings. 
    //  METHODS FOR ITERATING OVER STRINGS

    // Through characters
    for c in "Зд".chars() {
        println!("{c}");
    }
    output:
    З
    д

    // Through bytes
    for b in "Зд".bytes() {
        println!("{b}");
    }
    output:
    208
    151
    208
    180

    // But be sure to remember that valid Unicode scalar values may be made up of more than 1 byte.
}
